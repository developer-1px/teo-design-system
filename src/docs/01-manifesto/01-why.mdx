---
title: Why - The Philosophy
description: Why we are building this project, shifting focus from 'How' to 'Why'.
---

# Why

### 왜 이걸 만들려고 하나

* 사용자는 앱에서 **OS 수준의 기본 행동**(⌘Z, ⌘F, ⌘C/V, Esc, Tab, 방향키 등)을 **근육 기억**으로 기대한다.
* 웹앱에서 이 기본기가 빠지면, 기능이 많아도 **“완성도가 낮다/신뢰가 안 간다”**로 즉시 평가된다.
* 우리는 단순 CMS가 아니라 **Application 수준의 생산성 도구**를 만들고자 하며, 그 수준의 UX는 “컴포넌트 몇 개”로 얻어지지 않는다.
* AI 에이전트로 개발을 가속하려면, 화면마다 임기응변으로 키/포커스/Undo를 구현하는 방식은 **디자인·행동 정합성을 붕괴**시키고 품질을 떨어뜨린다.

---

## Intent

### 무엇을 달성하려는가(의도/방향)

* 앱 전역에서 **일관된 상호작용(Interaction) 규약**을 제공하는 “기본기 레이어”를 만든다.
* UI가 바뀌거나 구현이 교체되어도, 사용자가 체감하는 기본 동작은 **항상 동일**하게 유지한다.
* 기능 개발이 늘어날수록 “왜 여기선 안 되지?”가 늘어나는 대신, **기본기가 자동으로 따라오는 구조**를 만든다.
* 엔터프라이즈급 앱에서 요구되는:

    * 예측 가능한 키보드 동작
    * 포커스/오버레이 일관성
    * Undo/Redo 신뢰성
    * 검색/이동/선택의 통합 경험
      을 **표준으로 제공**한다.

---

## What

### 결과물은 무엇인가(정의)

“기본기 레이어”는 다음을 포함한다:

1. **Command 중심의 행동 표준**

* 사용자가 수행하는 핵심 행동(Undo, Find, Copy, Paste, Delete, Open/Close, Navigate 등)을 **명령(Commands)**으로 정의한다.
* 버튼 클릭, 메뉴 선택, 단축키 입력은 모두 같은 명령으로 수렴한다.

2. **컨텍스트 기반 키보드 일관성**

* 같은 키라도 상황(텍스트 입력/모달/현재 위젯/전역)에 따라 의미가 달라지는 것을 **규칙으로 정의**한다.
* 우선순위(입력 > 오버레이 > 위젯 > 페이지 > 전역)를 통해 “충돌”이 아니라 “예측 가능한 동작”이 되게 한다.

3. **Undo/Redo의 전역 신뢰성**

* 사용자가 기대하는 단위(의도 단위)로 되돌릴 수 있고,
* 되돌린 뒤에도 포커스/선택/뷰 상태가 자연스럽게 복구되는 수준을 목표로 한다.

4. **Selection / Clipboard / Find의 통합 경험**

* “선택”을 앱의 1급 상태로 취급해, 복사/붙여넣기/삭제/이동이 일관되게 작동한다.
* 검색(⌘F)과 찾아바꾸기(필요 시)는 앱 전역 기본기로 동작한다.

5. **Overlay/Focus의 앱 수준 규약**

* 모달/팝오버/팔레트/드롭다운이 쌓여도 Esc/Tab/focus restore가 일관된다.
* 키보드 사용자에게만 focus ring이 보이는 등 입력 방식에 맞는 시각적 규칙이 유지된다.

6. **엔터프라이즈 품질을 위한 관찰 가능성**

* “왜 지금 이 단축키가 동작/비동작했는지” 추적 가능한 상태/로그 구조를 가진다(운영/QA/디버깅 관점).

---

## Non-goals

### 이걸 만들지 않겠다는 것

* 엑셀/스프레드시트 자체를 복제하는 것이 목적이 아니다.
* 특정 UI 라이브러리나 디자인 시스템에 종속된 구현을 목표로 하지 않는다.
* 화면별 임기응변 구현(개별 컴포넌트가 제멋대로 키/포커스를 처리)은 지양한다.

---

## Success Criteria

### 성공의 기준(사용자 체감)

* 어떤 화면/위젯에서도 ⌘Z/⌘F/⌘C/V/Esc/Tab이 “당연히 기대한 대로” 동작한다.
* 키보드로만 사용해도 “앱이 제대로 만들어졌다”는 느낌이 든다.
* 기능이 추가돼도 기본기가 깨지지 않고, QA에서 “왜 안돼?” 류의 결함이 급감한다.
* AI 에이전트로 생성된 UI/코드에서도 정합성이 유지된다(규약을 자동으로 따르게 된다).

---

좋아. 아래는 **같은 내용을 서로 다른 목적에 맞게** 정리한 두 가지 버전이야.
(① 한 장짜리 1-pager / ② 팀 설득용 문서)
→ 그대로 Notion/Confluence/PRD에 붙여 써도 돼.

---

# ① One-Pager (1장 요약본)

## 제목

**Application-level Interaction Foundation**

---

### Why

사용자는 앱에서 **OS 수준의 기본 동작**(⌘Z, ⌘F, ⌘C/V, Esc, Tab, 방향키)을
학습하지 않고 **근육 기억으로 기대**한다.
이 기본기가 깨지는 순간, 앱은 “기능은 있는데 미완성”으로 인식된다.

우리는 단순 웹 UI가 아닌 **Application 수준의 생산성 도구**를 만들고자 하며,
이를 위해서는 컴포넌트 단위가 아닌 **전역 상호작용 규약**이 필요하다.

---

### Intent

* 앱 전반에 걸쳐 **일관된 키보드/포커스/Undo/Selection 규칙**을 제공한다
* UI 구현 방식이 바뀌어도 **사용자 체감 행동은 변하지 않게** 한다
* 기능이 늘어날수록 기본기가 약해지는 대신, **자동으로 따라오게 만든다**
* AI 에이전트 기반 개발에서도 **정합성과 품질을 유지**한다

---

### What

우리는 다음을 제공하는 **기본기 레이어(Foundation)** 를 만든다:

* **Command 중심 행동 모델**
  모든 사용자 행동은 명령(Command)으로 정의되고,
  클릭/메뉴/단축키는 동일한 명령으로 수렴한다.

* **컨텍스트 기반 키보드 규칙**
  입력 중 / 모달 / 위젯 / 페이지 / 전역의 우선순위를 명확히 정의한다.

* **전역 Undo/Redo 신뢰성**
  사용자 의도 단위로 되돌릴 수 있고,
  포커스·선택·뷰 상태까지 자연스럽게 복구된다.

* **Selection / Clipboard / Find 기본기**
  선택은 1급 상태이며, 복사/붙여넣기/삭제/검색이 앱 전반에서 일관된다.

* **Overlay / Focus 시스템 규약**
  Esc, Tab, focus restore, focus-visible 정책이 항상 동일하게 동작한다.

---

### Success Criteria

* 어떤 화면에서도 ⌘Z / ⌘F / ⌘C/V / Esc / Tab 이 “당연히” 동작한다
* 키보드만으로 사용해도 앱이 완성도 높게 느껴진다
* 기능이 늘어도 “왜 여기선 안 되지?”가 거의 나오지 않는다
* AI로 생성된 UI에서도 행동 정합성이 유지된다

---

### Non-Goals

* 특정 UI 라이브러리/디자인 시스템에 종속되지 않는다
* 엑셀/스프레드시트 자체를 구현하는 것이 목적은 아니다
* 화면별 임기응변 키 처리 방식은 지양한다

---

# ② 팀 설득용 문서 (문제 → 영향 → 해결 → ROI)

## 문제 (Problem)

현재 웹앱 개발 방식은:

* 키보드/Undo/포커스 처리가 **컴포넌트별로 흩어져 있고**
* 화면이 늘어날수록 **행동 규칙이 서로 달라지며**
* “왜 이 화면에선 ⌘Z가 안 되지?” 같은 **기본기 결함**이 누적된다

이 문제는 QA 단계에서 늦게 발견되고,
사용자에게는 “앱이 덜 만들어졌다”는 인상을 준다.

---

## 영향 (Impact)

* 사용성 신뢰도 하락 → 학습 비용 증가
* 기능 추가 시 회귀 버그 증가
* AI 에이전트 기반 개발 시
  → 디자인·행동 정합성 급격히 붕괴
* 엔터프라이즈 고객 기준에서
  “기본기 미흡”으로 평가될 위험

---

## 해결 (Solution)

**UI 위가 아닌, UI 아래에 “기본기 레이어”를 둔다**

핵심 원칙:

1. 모든 사용자 행동은 **Command** 로 정의된다
2. 키보드/클릭/메뉴는 같은 Command를 호출한다
3. 컨텍스트(입력/모달/위젯/전역)에 따라 해석 규칙이 정해진다
4. Undo/Redo는 전역 트랜잭션 단위로 관리된다

이 레이어는:

* UI 라이브러리와 독립적이며
* 재사용 가능하고
* 테스트 가능하다

---

## 기대 효과 (ROI)

### 개발 생산성

* 기능 추가 시 기본기 재구현 불필요
* “왜 안 되지?” 디버깅 시간 감소

### 품질

* 키보드/Undo/포커스 관련 버그 급감
* QA 체크리스트 단순화

### 사용자 경험

* 학습 없이도 “익숙한 앱”처럼 사용 가능
* 엔터프라이즈 고객 신뢰도 상승

### AI 활용

* 에이전트가 **규칙을 자동으로 따르게 됨**
* 결과물의 정합성과 일관성 유지

---

## 한 문장 요약(설득용)

> **이건 새로운 기능을 만드는 일이 아니라,
> 앞으로 만들어질 모든 기능의 완성도를 보장하는 인프라를 만드는 일이다.**
