import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const INPUT_FILE = path.resolve(
  __dirname,
  "../src/design-system/token/token.const.1tier.ts",
);
const OUTPUT_FILE = path.resolve(__dirname, "../src/style/tokens.1tier.css");

const content = fs.readFileSync(INPUT_FILE, "utf-8");

// Helper to extract array content
function extractScale(name) {
  const regex = new RegExp(
    `export const ${name} = \\[([\\s\\S]*?)\\] as const;`,
  );
  const match = content.match(regex);
  if (!match) return [];

  return match[1]
    .split(",")
    .map((s) => s.trim())
    .filter((s) => s && !s.startsWith("//"))
    .map((s) => s.replace(/['"]/g, "")); // Remove quotes for strings
}

const scales = {
  space: {
    data: extractScale("SpaceScale"),
    prefix: "space",
    transform: (v) => `${v}px`,
  },
  iconSize: {
    data: extractScale("IconSizeScale"),
    prefix: "icon-size",
    transform: (v) => `${v}px`,
  },
  size: {
    data: extractScale("SizeScale"),
    prefix: "size",
    transform: (v) => `${v}px`,
  },
  container: {
    data: extractScale("ContainerSizeScale"),
    prefix: "container-size",
    transform: (v) => `${v}px`,
  },
  radius: {
    data: extractScale("RadiusScale"),
    prefix: "radius",
    transform: (v) => `${v}px`,
  },
  borderWidth: {
    data: extractScale("BorderWidthScale"),
    prefix: "border-width",
    transform: (v) => `${v}px`,
  },
  fontSize: {
    data: extractScale("FontSizeScale"),
    prefix: "font-size",
    transform: (v) => `${v}px`,
  },
  lineHeight: {
    data: extractScale("LineHeightScale"),
    prefix: "line-height",
    transform: (v) => v / 100,
  },
  opacity: {
    data: extractScale("OpacityScale"),
    prefix: "opacity",
    transform: (v) => v / 100,
  },
  zIndex: {
    data: extractScale("ZIndexScale"),
    prefix: "z-index",
    transform: (v) => v,
  },
  elevation: {
    data: extractScale("ElevationScale"),
    prefix: "elevation",
    transform: (v) => v, // Unitless or map to specific shadow? Keeping unitless for now as it's likely for z-index or strict shadow mapping
  },
  aspectRatio: {
    data: extractScale("AspectRatioScale"),
    prefix: "aspect-ratio",
    formatter: (v) => {
      // v is like "16_9"
      const val = v.replace("_", "/");
      return `--aspect-ratio-n${v}: ${val};`;
    },
  },
};

// Start CSS content
let css = `/**
 * Generated by scripts/generate-tokens.js
 * Do not edit directly.
 */

:root {
`;

// Generate CSS variables
Object.entries(scales).forEach(([key, config]) => {
  css += `\n  /* ${key.charAt(0).toUpperCase() + key.slice(1)} */\n`;

  config.data.forEach((item) => {
    // Skip if item is empty or comment (simple split might leave some)
    if (!item || item.toString().trim() === "") return;

    // Handle comments in array that might have leaked into item string if split by comma was rough
    // But our simple regex split creates clean items usually if code is formatted.
    // Let's assume input is number or string.

    // Handle inline comments like "192, // ..."
    // The filter above removes lines starting with // but split(',') might keep trailing comments.
    // Let's clean the item:
    const cleanItem = item.split("//")[0].trim();
    if (!cleanItem) return;

    if (config.formatter) {
      css += `  ${config.formatter(cleanItem)}\n`;
    } else {
      css += `  --${config.prefix}-n${cleanItem}: ${config.transform(cleanItem)};\n`;
    }
  });
});

// Add SizeKeywords
const sizeKeywordsMatches = content.match(
  /export const SizeKeywords = \[([\s\S]*?)\] as const;/,
);
if (sizeKeywordsMatches) {
  const keywords = sizeKeywordsMatches[1]
    .split(",")
    .map((s) => s.trim().replace(/['"]/g, ""))
    .filter((s) => s);

  css += `\n  /* Size Keywords */\n`;
  keywords.forEach((k) => {
    if (!k) return;
    // Map keywords to standard CSS values if possible, or just keep as placeholders?
    // In tokens.layout.css: --size-full: 100%; --size-screen: 100vh; etc.
    // We'll need a mapping for these.
    let val = "";
    switch (k) {
      case "full":
        val = "100%";
        break;
      case "screen":
        val = "100vh";
        break;
      case "min":
        val = "min-content";
        break;
      case "max":
        val = "max-content";
        break;
      case "fit":
        val = "fit-content";
        break;
      case "auto":
        val = "auto";
        break;
      default:
        val = "initial"; // fallback
    }
    css += `  --size-${k}: ${val};\n`;
  });
}

// Radius Aliases are 2-tier tokens that reference 1-tier numeric tokens
// No need to generate separate CSS variables - they're defined in TypeScript only

css += `}\n`;

fs.writeFileSync(OUTPUT_FILE, css);
console.log(`Generated ${OUTPUT_FILE}`);
